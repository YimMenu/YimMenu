import re
import sys
print("Generating new JSON macros.")

settings_hpp_file_path = sys.argv[1]

cpp_file_buffer = ""

def find_differences(list1, list2):
    list2_set = set(list2)
    list_1_items_missing_in_list_2 = [x for x in list1 if x not in list2_set]
    if len(list_1_items_missing_in_list_2) > 0:
        print(list1)
        print(list2)
        print("items missing in vanilla:")
        print(list_1_items_missing_in_list_2)
        print()


lines = open(
    settings_hpp_file_path,
    "r",
).readlines()


class Field:
    def __init__(self, name, ignore_flag, generator_ignore_flag, line_number):
        self.name = name
        self.ignore_flag = ignore_flag
        self.generator_ignore_flag = generator_ignore_flag
        self.line_number = line_number


class Struct:
    def __init__(self, name, fields=None):
        self.name = name
        self.fields = []


vanilla_yimmenu_serde = []
all_fields_serializers = []

struct_stack = []
struct_name_to_struct = dict()

ignore_flag = False
generator_ignore_flag = False
line_number = 0
for line in lines:
    line_number += 1
    line = line.strip()

    if line.startswith("struct") or line.startswith("class") and ";" not in line:
        struct_name = line.split()[1].strip()
        new_struct_name = ""
        if len(struct_stack) > 0:
            new_struct_name += struct_stack[0].name + "::"
        struct_name = new_struct_name + struct_name
        cur_struct = Struct(struct_name)
        struct_name_to_struct[struct_name] = cur_struct
        struct_stack.insert(0, cur_struct)
        continue

    is_inline_struct_var_definition = line.startswith("} ") and line.endswith("{};")
    if is_inline_struct_var_definition:
        struct_stack.pop(0)
    elif line == "};":
        struct_stack.pop(0)
        continue

    if len(struct_stack) > 0:
        if line == "// Json Parser: Ignore":
            ignore_flag = True
            continue

        if line == "// Json Parser: Generator Ignore":
            generator_ignore_flag = True
            continue

        # if "NLOHMANN_DEFINE_" in line:
        #     vanilla_yim_serde = (
        #         line.split(";")[0].split("(")[1].replace(")", "").split(",")
        #     )
        #     vanilla_yim_serde = list(map(lambda x: x.strip(), vanilla_yim_serde))
        #     vanilla_yim_serde = (vanilla_yim_serde[0], sorted(vanilla_yim_serde[1:]))
        #     vanilla_yimmenu_serde.append(vanilla_yim_serde)

        if ";" not in line:
            continue

        potential_func_hint_1 = line.find("(")
        potential_func_hint_2 = line.find("const")
        potential_func_hint_3 = line.find("();")
        if potential_func_hint_1 != -1 and potential_func_hint_2 != -1:
            # print(line)
            continue
        if potential_func_hint_3 != -1:
            # print(line)
            continue

        if "*" in line and "const char" not in line:
            continue

        parts = line.split("=")[0].split("{")[0].split("[")[0].split(";")[0].split()
        # print(parts)
        field_name = parts[-1]
        # print(field_name)

        struct_stack[0].fields.append(
            Field(field_name, ignore_flag, generator_ignore_flag, line_number)
        )
        # if generator_ignore_flag:
        #     print(field_name)
        ignore_flag = False
        generator_ignore_flag = False

cpp_file_buffer += "// GENERATED BY settings_json_serde_gen.py" + "\n"
cpp_file_buffer += "// Mark setting that must always be excluded from JSON serialization," + "\n"
cpp_file_buffer += "// even when generating the structural representation of the settings, with `// Json Parser: Generator Ignore`" + "\n"
cpp_file_buffer += "// Mark setting that should not be persistently stored between multiple instances of the DLL being loaded with `// Json Parser: Ignore`" + "\n"
cpp_file_buffer += "namespace big" + "\n"
cpp_file_buffer += "{" + "\n"
cpp_file_buffer += "//#define SERIALIZE_EVERYTHING" + "\n"
cpp_file_buffer += "#ifdef SERIALIZE_EVERYTHING" + "\n"

vanilla_yimmenu_serde = sorted(vanilla_yimmenu_serde, key=lambda x: x[0])

# Generate serde everything nlohmann json macros
# Used mostly for generating bindings to other languages.
for struct_name, struct in reversed(struct_name_to_struct.items()):
    cpp_code = f"\tNLOHMANN_DEFINE_TYPE_NON_INTRUSIVE({struct_name}, "
    # cpp_code = f"\tNLOHMANN_DEFINE_TYPE_INTRUSIVE({struct_name}, "

    added_any_field = False
    for field in struct.fields:
        if not field.generator_ignore_flag:
            cpp_code += f"{field.name}, "
            added_any_field = True

    if not added_any_field:
        continue

    cpp_code = cpp_code[:-2]

    cpp_code += ")"

    cpp_file_buffer += cpp_code + "\n"

    # all_field_serde = cpp_code.split("(")[1].replace(")", "").split(",")
    # all_field_serde = list(map(lambda x: x.strip(), all_field_serde))
    # all_field_serde = (all_field_serde[0], sorted(all_field_serde[1:]))
    # all_fields_serializers.append(all_field_serde)

# all_fields_serializers = sorted(all_fields_serializers, key=lambda x: x[0])

# for i in range(0, len(all_fields_serializers)):
#     find_differences(all_fields_serializers[i][1], vanilla_yimmenu_serde[i][1])

cpp_file_buffer += "#else" + "\n"

# Generate nlohmann json macros
for struct_name, struct in reversed(struct_name_to_struct.items()):
    cpp_code = f"\tNLOHMANN_DEFINE_TYPE_NON_INTRUSIVE({struct_name}, "
    # cpp_code = f"\tNLOHMANN_DEFINE_TYPE_INTRUSIVE({struct_name}, "

    added_any_field = False
    for field in struct.fields:
        if not field.generator_ignore_flag and not field.ignore_flag:
            cpp_code += f"{field.name}, "
            added_any_field = True

    if not added_any_field:
        continue

    cpp_code = cpp_code[:-2]

    cpp_code += ")"

    cpp_file_buffer += cpp_code + "\n"

cpp_file_buffer += "#endif\n"
cpp_file_buffer += "}\n"

with open(settings_hpp_file_path, 'r') as file:
    lines = file.readlines()

# Find the line index that starts with "GENERATED BY"
start_index = None
for i, line in enumerate(lines):
    if "// GENERATED BY" in line.strip():
        start_index = i
        break

if start_index is not None:
    # Remove lines starting from the "GENERATED BY" line
    lines = lines[:start_index]

    # Add the new generated code at the end of the file
    lines.append(cpp_file_buffer)

    # Save the modified content back to the file
    with open(settings_hpp_file_path, 'w') as file:
        file.writelines(lines)
